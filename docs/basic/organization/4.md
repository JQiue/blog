---
title: 存储器
category: 计算机基础
author: JQiue
---

## 计算机存储器

### 分类

+ 存储器按照介质分为：半导体存储器和磁存储器

像内存，U盘，固态硬盘都是属于半导体，而磁带和磁盘都是磁存储器

+ 按存储方式分类：随机存储器（RAM）、串行存储器、只读存储器（ROM）

### 存储器的层次结构

读写速度和存储容量都是选择存储器要考虑的因素，根据这些因素就为存储器划分了不同的层次来满足不同的需求

+ 缓存：速度最快，价格最高，存储容量最小，常用于 CPU 内部
+ 主存：速度适中，价格适中，存储容量适中，常用于计算机内部
+ 辅存：速度最慢，价格最低，存储容量最大，常用于外部设备

1. 缓存-主存层次：在 CPU 与主存之间增加一层速度快的 Cache，解决主存速度不足的问题，利用了局部性原理
2. 主存-辅存层次：在主存之外增加辅助存储器，用来解决主存容量不足的问题

::: tip 局部性原理
指 CPU 访问存储器时，无论时存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中，将这个区域换成缓存即可大大提高速度
:::

### 主存储器和辅助存储器

+ RAM（随机存储器：Random Access Memory）：存储的方式是随机的，存储的位置和时间没有关系，通过电容存储数据，必须隔一段时间刷新一次，如果停电，将会丢失所有数据

主存储器由半导体存储器，驱动器，译码器，读写电路，控制电路组成

CPU 中的主存数据寄存器（MDR）通过数据总线和主存中的读写电路进行连接，CPU 中的主存地址寄存器（MAR）通过地址总线和译码器连接

这样 CPU 就可以通过地址总线获得数据位置，同时通过数据总线来传输数据

::: tip
不同位数的操作系统对内存的支持也不同，比如 32 位操作系统只能支持 2^32^ = 4 * 2^30^ = 4GB，即使加更多的内存它最多只能支持4GB，这是因为地址总线的范围最多就是4GB的大小，对于 64 位操作系统来说，内存的支持达到了 2^64^ = 2^34 \* 2^30^ = 2^34^GB
:::

+ HDD（机械硬盘：hard disk drive）：盘片表面是可磁化的特性材料，盘片每分钟几千转，磁头可以移动到指定位置改变电磁的极性方式来进行读写操作

在操作系统中，各个进程可能会不断提出不同对磁盘进行读写操作的请求，因此有必要位磁盘设备建立一个等待队列，因此就产生了调度算法

1. 先来先服务算法：按顺序访问进程的磁道读写需求，公平简单
2. 最短寻道时间优先算法：优先访问距离磁头最近的磁道
3. 扫描算法（电梯调度）：磁头每次只往一个方向移动，到达尽头再反方向移动
4. 循环扫描算法：是对扫描算法的改进，消除了对两端磁道请求的公平

### 高速缓存

CPU 与 cache 之间的数据交换是以字为单位的，而 cache 与主存之间的数据交换是以块为单位的

1. 字：是存放再一个存储单元中的二进制代码组合
2. 字块：存储在连续的存储单元中而被看作是一个单元的一组字

假设一个字有 32 位，一个字块共 B 个字，主存共 M 个字块，那么主存总字数：B \* M，主存总容量：B \* M \* 32

字的地址包含两个部分，前 m 位指定字块的地址，后 b 位指定字在字块中的地址

假设主存用户容量位 4G，字块大小位 4M，字长为 32 位，则对于字地址中的块地址 m 和块内存地址 b 的位数，至少应该是多少

4G = 4096M  
字块数： 4096 / 4 = 1024  
字块地址m：log~2~1024 = 10  
块内字数：4M / 32bit = 1048576  
块内地址b：log~2~1048576 = 20

主存和缓存的逻辑结构类似，缓存的容量较小，缓存的速度更快

CPU 需要的数据在缓存里，就不需要去主存拿，否则需要去主存拿

命中率是衡量缓存的重要性能指标，理论上 CPU 每次都能从告诉缓存中取数据的时候命中率为 1

但这只是理论上的，因为容量不及主存，所以命中率永远不可能为 1

命中率计算方式为：访问 Cache 的次数除以访问主存的次数加访问 Cache 的次数

同时访问效率也是衡量缓存的重要指标

CPU 访问 Cache - 主存的平均时间为：命中率 \* 访问缓存的时间 + (1 - 命中率) \* 访问主存的时间

访问效率为：访问缓存时间 / 平均时间

::: tip 练习
假设 CPU 在执行某段程序时，共访问了 Cache 命中2000次，访问主存50次，已知 Cache 的存取时间为 50ns，主存的存取时间为 200ns，求 Cache - 主存系统的命中率、访问效率、平均访问时间？  
命中率：2000/(2000+50) = 0.97  
CPU 平均访问时间：0.97 \* 50 +(1 - 0.97) \* 200 = 54.5  
访问效率：50 / 54.5 = 0.91 = 91%  
:::

#### 高速缓存的替换策略

对于 CPU 来说，每次能从高速缓存中取到数据无疑能提高效率，这个时候就需要一个性能良好的缓存替换策略，使 CPU 访问缓存中的的数据都是需要的

当 CPU 访问的数据不在缓存中时，就需要从主存中载入数据到缓存中，这就是高速缓存的替换时机，由此产生了不同的算法

+ 随机算法：随机替换掉缓存中的字块
+ 先进先出（FIFO）：看作成一个队列，优先替换最先进入队列的字块
+ 最不经常使用算法（LFU）：优先替换最不经常使用的字块，但是需要额外的空间记录字块的使用频率
+ 最近最少使用算法（LRU）：优先替换一段时间内很少使用的字块，一般使用双向链表实现，把当前访问节点置于链表前面（保证头部节点时最近使用的），替换掉链表尾部字块
