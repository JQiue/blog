---
title: 概论
category: 计算机
author: JQiue
---

大部分软件都是使用高级程序语言编写的，经过编译器的翻译，才可以转换为计算机可执行的机器代码，而编译器所生成的代码的正确性和质量会影响成千上万个软件，因此编译器构造原理是计算机领域中非常重要的组成部分，所以编译原理就是一门研究”翻译“的技术，而编译器则是编译原理的具体技术实现

## 语言处理器

语言处理器就是用来处理高级语言的程序，也叫编译器，它能够阅读某一种高级语言，并将它转换成一个等价的、计算机能够识别的机器语言

@flowstart
st=>inputoutput: 源程序
e=>inputoutput: 目标程序
process=>operation: 编译器

st->process->e
@flowend

如果目标程序是一个可执行程序，它就能够被用户所使用，接受输入信息，并产生输出信息

@flowstart
input=>inputoutput: 输入
output=>inputoutput: 输出
process=>operation: 目标程序

input(right)->process(right)->output(right)
@flowend

解释器（interpreter）是另一种语言处理器，它不会生成一个目标程序，而是将源程序作为输入的方式来执行源程序，解释器本身是用更低级的语言所编写

@flowstart
input=>inputoutput: 输入+源程序
output=>inputoutput: 输出
process=>operation: 解释器

input(right)->process(right)->output(right)
@flowend

::: tip
Java 的语言处理器结合了编译和解释的过程，一个 Java 源程序首先会被编译字节码文件（bytecode），然后将字节码文件交给虚拟机去解释执行，这样就屏蔽了底层差异，也就体现了 Java 的跨平台性特点
:::

除了编译器之外，创建一个目标程序可能还需要其他的程序，比如 C 语言的预处理，会将其他文件和源程序一起合并在一个文件中，这个程序叫做预处理程序（preprocessor），同时还会将称之为宏的缩写形式转换为源程序的代码，实现了用编译器帮忙写程序的功能，然后将预处理过的程序传入编译器，编译器产生一个汇编语言程序作为其输出，因为汇编语言方便调试，让后将这个汇编程序交给汇编器（assembler）进行处理生成可重定位的机器代码。而程序经常会被分成多个部分进行编译，链接器（linker）会将机器代码和其他可重定位的目标文件以及库文件连接到一起，形成真正能够在机器上运行的代码，最后加载器（loader）会把可执行文件放到内存中执行

@flowstart
source=>inputoutput: 源程序
sourceafter=>inputoutput: 预处理后的源程序
relocatable=>inputoutput: 可重定位机器代码
object=>inputoutput: 目标汇编程序
machine=>inputoutput: 目标机器代码
preprocessor=>operation: 预处理器
compiler=>operation: 编译器
assembler=>operation: 汇编器
linker_loader=>operation: 链接器和加载器

source->preprocessor->sourceafter->compiler->object->assembler->relocatable->linker_loader->machine
@flowend

### 总结

1. 编译器会生成目标程序，相对于解释器会更快，但是不易诊断错误
2. 解释器不会生成目标程序，而是将程序本身作为输入交给解释器去执行，容易诊断错误，但是相对于编译器较慢
3. 编译器产生汇编语言而不是机器语言的原因是方便调试优化
4. C 语言是最接近汇编的高级语言，可以很方便的控制寄存器在内的所有硬件，所以大部分编译器/解释器都是使用 C 语言所编写的

## 语言处理器的流程

一个语言处理器由分析部分和综合部分组成

分析是将源程序分解成多个组成要素，并在要素之上加上语法结构，然后通过语法结构来创建一个源程序的中间表示，如果分析检查出了源程序没有按照正确的语法构成，则会提醒用户得以修正，同时分析部分还会将源程序的信息存放在一个符号表（symbol table）的数据结构中，符号表和中间表示会一起交给综合部分

综合部分会根据符号表和中间表示信息来构造目标程序，分析部分通常被称为前端（front end），而综合部分被称为后端（back end）

有些编译器会在前端后端之间有一个与机器无关的代码优化步骤，这是为了使后端生成质量更高的目标程序，否则会生成一个质量不那么好的目标程序，但是优化部分是可选的

@flowstart
charstream=>inputoutput: 字符流
lexical=>operation: 词法分析器
symbostream=>inputoutput: 符号流
syntax=>operation: 语法分析
syntaxtree=>inputoutput: 语法树
intermediate=>operation: 中间代码生成器
intermediaterepresentation=>inputoutput: 中间表示形式
codegenerator=>operation: 代码生成器
objectcode=>inputoutput: 目标机器语言
codeoptimizer=>operation: 代码优化器
objectcodeafter=>inputoutput: 优化后的目标机器语言

charstream->lexical->symbostream->syntax->syntaxtree->intermediate->intermediaterepresentation->codegenerator->objectcode->codeoptimizer->objectcodeafter
@flowend

### 词法分析

编译器的第一个步骤会叫词法分析（lexical analysis）或扫描（scanning），分析器会读入字符流，将它们组织成有意义的词素序列，每个词素都会被分析器产生一个如下形式的词法单元（token）：

`<token-name, attribute-value>`

这个词法单元会被送到语法分析中，`token-name`是语法分析使用的抽象符号，而`attribute-value`是指向符号表中关于词法单元的具体条目，符号表会被语义分析和代码生成器所使用

假设有一个赋值语句：

`foo = bar + baz * 3`

这个语句中的字符会被整理成以下词素，并映射成词法单元：

```text
foo<id, 1>
=<=>
bar<id, 2>
+<+>
baz<id, 3>
*<*>
3<3>
```

其中 id 是表示标识符的抽象符号，而 1 则指向的是符号表 foo 对应的条目，一个条目则存放着与该标识符有关的信息，比如它的名字和类型，因为赋值符号不需要属性值，所以省略了第二个分量，为了方便表示词素将本身作为抽象符号的名字，分隔词素之间的空格会被忽略掉，经过词法分析后，赋值语句将会生成如下的词法单元序列：

`<id, 1> <=> <id, 2> <+> <id, 3> <*> <60>`

### 语法分析

编译器的第二个步骤叫语法分析（ayntax analyasis）或解析（parsing），分析器会根据词法单元生成一个语法树的中间表示，每个内部节点表示一个运算，该节点的子节点表示该运算符的分量

### 语义分析

语义分析（semantic analyzer）通过语法树和符号表中的信息来检查源程序是否与语义定义的一致，同时收集类型信息，把信息放入语法树和符号表中，语义分析最重要的部分是进行类型检查，检查每一个运算符是否有匹配的运算分量，比如一个数组的下标必须是整数，如果用浮点数则编译器必须报告错误，当然一些编译器也存在自动类型转换

### 中间代码生成

一个编译器会生成很多中间表示，语法树是其中一种，经过语法分析和语义分析后，应当生成一个更为低级的中间表示，它应该符合易于生成和轻松翻译成目标语言的特点

### 代码优化

代码优化器会将中间代码生成更好的目标代码，也就意味着更快，不同的编译器所做的优化工作量非常大，这很可能会在编译阶段花掉很多时间

### 代码生成

代码生成器会将中间表示作为输入，将它映射为当前机器的目标语言，将中间表示翻译成目标语言，通常是为每个变量分配寄存器或内存的位置，然后会被翻译成等价的机器指令序列

### 符号表

编译器最重要的就是记录源程序中变量的名字，并收集有关名字的各种属性信息，符号表为每个变量创建了一个条目用于记录，每个字段就是该变量的各个属性，便于编译器获取或快速存放

### 多个步骤组成趟

在一个特定的实现中，多个步骤的活动可以被组合成一趟（pass），也叫遍。可以将词法分析，语法分析，语义分析，中间代码生成这几个部分组合成一起成为一趟，一般多趟的编译程序会更少的占用内存，但是也意味着消耗了更多的编译时间

## 程序设计语言的发展历程

早期的语言使用由0，1序列组成的机器语言编程，这种编程速度非常慢，且写出的程序难以理解和修改

到了后代为了更好的理解机器语言，就将机器语言使用一种助记符来表示，这样大大加快了编程效率，尤其是将宏指令加入到这种语言中，就让整个编程开发效率更高了，这就是汇编语言的产生

::: tip 宏
根据一个预定义的规则替换一定的文本模式
:::

再到后来为了用于科学计算的 Fortan 语言问世，设计了更高层次的表示方法，使程序员更加容易编写程序，接下来的十几年有很多新特性的程序设计语言问世，它们使编程更容易，更强大。

虽然编程语言有几千种，但还是要将这些划分为类，通过代数来划分，第一代即机器语言，第二代即汇编语言，第三的即 Fortan，Lisp，C，C++，Java这样的高级语言，而第四代是为特定应用设计的语言，比如用于数据库查询的 SQL 语言。通过完成人物的方式来划分，指明如何完成一个计算任务的语言称为强制式，而指明要进行哪些计算的语言称为声明式。C，C++，Java都是强制式语言

面向对象语言指的是支持面向对象编程的语言，它是一种相互作用的对象组成程序的编程风格，C++，Java 和 Ruby 都是常用的面向对象语言

脚本语言是一种具有高层次的解释性语言，通常将多个计算过程粘合在一起，这些计算过程被称为脚本，JavaScript，PHP，Python 都是常用的脚本语言，通常使用脚本语言编写的程序要比其他语言写的等价程序短很多

## 程序设计语言基础

### 静态和动态

在为一个语言设计编译器时，首先面对的重要问题就是编译器能够对一个程序做出哪些判定，如果一个语言使用策略支持编译器静态决定某个问题，那么这个语言就使用了静态策略，也可以说在编译时刻（compile time）决定，另一方面一个只荀彧在运行程序的时候做出决定的策略被称之为动态策略（dynamic policy），或者说在运行时刻（run tiem）做决定

比如一个变量的作用域可以通过阅读程序就可以确认的作用域那么这个语言就是静态作用域，否则就是动态作用域，动态作用域的变量，同一个变量会指向这个变量几个声明的某一个

比如 Java 中的 static 关键字声明的变量，也就是说不管创建了多少个这个类的对象，但这个变量只会存在一个，编译器可以确定该变量在内存中的位置，如果省略了 static，则每一个对象都会有自己用于存放变量的位置，导致编译器无法在运行程序前来预先确定这些变量的位置

### 环境和状态

环境指的是从一个名字到存储位置的映射，因为变量就是指内存地址，而状态是一个内存位置到它们的值的映射

### 静态作用域和块结构

一个声明的作用域由该声明所处在程序中的位置隐含决定，但 java 等语言也通过public、private 和 protected 等关键字明确的控制作用域

::: tip 名字、变量、标识符
名字和变量虽然通常指的是同一个事物，但是最好小心使用它们，以便于区分编译时和运行时名字所指的内存位置
标识符是一个由字母和字符串组成的，用来指向一个实体，比如一个数据对象，类或者类型。所有的表示符都是名字，但是并不是所有的名字都是标识符
变量指向存储中的某个位置，同一个标识符可能会被多次声明，每一个声明引入一个新的变量，即使标识符只声明一次，但递归中的标识符会在不同的时刻指向不同的位置
:::

::: 过程、函数、方法
过程是指调用一个子程序时，就统称为“过程”，但是当明确某个语言时，就应该根据不同情况讨论，C 语言只有函数，所以把过程称为函数，而 Java 则是方法
:::

块包含了一个声明的序列，这些都用花括号包围起来，语法也允许一个块嵌套另一个块，C 语言都具有块结构，但是不能在函数内部定义另一个函数

::: 声明、定义
声明和定义虽然看起来很相似，但是又很大的不同，声明是告诉事物的类型，定义告诉它们的值
:::

### 参数传递机制

所有的程序设计语言都有会参数传递的过程，但是使用哪一种传递机制决定了调用代码序列如何处理参数，大部分语言要么是“值调用”，要么是“引用调用”，或者两者都用

在值调用中，会对实在参数求值（表达式）或拷贝（变量），这些值会放在属于被调用过程的相应形式参数的内存位置上，效果是，被调用过程所做的所有有关形式参数的计算都会局限于这个过程，相应的实在参数本身不会被改变

但是 C 语言可以传递变量的指针，使得变量的值能够被调用者修改，同样的，其他语言中的数组传递实际上是想被调用过程传了一个指向数组本身的指针或引用，虽然看起来像是拷贝

在引用过程中，是将是在参数的地址作为相应的形式参数的值传给被调用者，在调用者的代码中使用形式参数时，会沿着这个指针找到调用者指出的内存位置。

### 别名

引用调用会产生一个有趣的效果，多个形式参数指向同一个位置，这种变量也可以被称之为另一个变量的别名

### 总结

+ 语言处理器：一个集成的开发环境，包括多个种类的语言处理器，比如编译器、解释器、汇编器、连接器、加载器、调试器等
+ 编译器的步骤：一个编译器通过一系列步骤，每个步骤把源程序从一个中间表示转换为另一个中间表示
+ 机器语言和汇编语言：机器语言是第一代语言，汇编语言是第二代语言，这些语言编程效率都不好
+ 高级语言：更高层次的程序设计语言，大大加快了程序的开发效率，也更容易理解
+ 作用域规则：一个变量声明的作用域是一段上下文，在此上下文中对这个变量的使用指向这个声明，如果阅读程序就能确认作用域，这个语言就是静态作用域，反之是动态作用域
+ 环境：名字和内存位置关联，然后再和值关联，环境将名字映射成内存位置，状态位置映射成它的值
+ 块结构：是一种语句序列，会产生局部的作用域，块是可以嵌套的
+ 参数传递：参数可以通过值传递或引用传递传给调用者，当通过值传递方式传递大型对象（数组，类的实例等）时，实际上传递的值是指向这些对象本身的引用
+ 别名：多个变量可以指向同一个对象
